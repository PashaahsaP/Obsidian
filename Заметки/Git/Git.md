`Система контроля версий` - записывает историю изменения файла или файлов, чтобы была возможность вернуться.
Виды систем по виду хранения:
- локальные
- Централизованные (1 сервер) , если сервер даст сбой не будет доступа к репозиторию
- Распределенная система(несколько серверов)
`Git`  хранит изменения данных как набор снимков состояния файловой системы. Когда сохраняеться состояние делаеться снимок всех файлов и сохраняеться ссылка на этот снимок, вместо файлов которые не претерпели изменений, указываеться ссылка на ранне сохраненные снимки.
![[Снимки состояния git.png]]
`Git` воспринимает данные как поток снимков. Работает как локально так и как распре.систем. Данные храняться по хэшу а не имени файла.

Файлы могут храниться в трех состояниях: зафисированный(committed), модифицированный(modified), и индексированный(staged):
- committed означает что данные сохранены в локальной базе
- modified говорит о том что изменения внесены в файл но не зафиксирован в базе.
- staged означает что текущая версия модифицируемого файла помеченная для следующий фиксации.
`Git` делиться на три области:
- Рабочая папка это место куда выгружаеться одна из версий проекта.Извлекаються из сжатой базы в `git`.
- Папка git  место хранения метаданных и базы данных проекта
- Область индексирования файл, обычно в git папке, хранящая в себе то что войдет в следующию фиксацию
![[Области Git.png]]
Для установки конфигурации `git` есть файл `config`.

Есть два подхода создания репозитория:
1) Добавить в git существующий проект
2) Клонировать репозиторий с сервера (забирает все версии файлов за всю историю проекта)
```Git
1)
git init //добавить папку git
git add .
git commit -m ""
```
```Git
2)
git clone [url] or git clone [url] [folder]
```

Файл в папке может быть `отслеживаемым` и `неотслеживаемый`:
- Отслеживаемый это файлы входящий в последний снимок(git commit), он может быть неизмененным, измененным и подготовленным к фиксации.
- Неотслеживаемый это файлы не вошедшие в последний снимок и не проиндексированые(git add) делает файлы отслеживаемые и проиндексированные. Такие файлы помещаються под заголовком `Untracked files`
Проиндексированные файлы помещаютсья под заголовком `Change to be commited`
Измененный отслеживаемый файл `Changed but not staged for commited`
![[Жизненный цикл файлов git.png]]
Если файл проиндексировать и изменить потом, то когда будет файл фиксироваться, то состояния файла будет браться при индексации(изменения не будут зафиксированны).



						`Ветвления в Git`
Ветвление это отклонение от основной линии разработки, после которой работа перестает затрагивать основную линию. 
При фиксации состояния `git` сохраняет объект-коммит содержащий указатель на снимок индексирования и еще имя, почта автора и указатель на предка или предков если происходит слияние веток.Если первая фиксация нет указателя на предка.
Ветка в `git` это указатель на один из коммитов(по умолчанию master). После последущей фиксации, указатель переключаеться на вновь созданный снимок(который хранит ссылку на предыдущий снимок).
Так как ветка указывает на коммит то при переключнии на другую ветку файлы в рабочей папке будут соответствовать тому коммиту на который указывает ветка.Если `git` не сможет вернуться к снимку то переключиться на ветку не получиться.
При смене веток `git` сверяет коммиты из двух веток(т.е. файлы на момент фиксации), если файлы одинаковые в обоих коммитах и есть какие то незафиксированные изменения то переход пройдет нормально измения перенесуться на другую ветку(!!!быть остророжным, чтобы не закоммитить изменения из другой ветки не там).Если файлы у коммитов разные то git должен подгрузит состояние файла из коммита и если были какие то незафиксированние изменения то git не даст перейти т.к. нужно зафиксировать данные(https://www.youtube.com/watch?v=KxKjBneF_NI&list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb&index=13)
Чтобы знать какая ветка текущая есть указатель `HEAD`. 
Может возникать ситуация когда файл с веткой могут иметь одно и тоже имя(путь)(сначала идет поиск ссылки на коммит или ветку). Чтобы предотвратить неопределенность и получить файл:`git checkout -- master` нужно указать два дефиса перед именем файла.


Тематические ветки это ветки в которых ведеться разработка под определенную функциональность или для тестировать. Основная ветка используеться для стабильной версии которая может пойти в работу.

Слияние `fast-forward` происходит когда отсутствуют расходящиеся изменения. Это значит если вернуть по коммитам ветки назад до коммита откуда пошло отвлетвление и этот коммит от которого пошло отвлетвление являеться актуальным т.е. небыло более созданно коммитов. 
Также такой коммит называется прямой предок.Но если в основной ветке создаеться коммит тогда не получиться слить ветки таким способом. Также такое слияние называют `перемоткой` Происходит просто смешение указателя вперед.

Если же коммит ветки не являеться прямым предком для ветки(с которой осущ. слияние) то выполняеться трехэтапное слияние. Используеться два состояния на которые указывают вершины веток и их общего предка. Вместо смещения указателя вперед формируеться новое состояние и автоматически создаеться коммит для этого состояния. Такой коммит называеться `коммит слияния`. 
Когда выполняеться слияние через `merge` указатель `ORIG_HEAD` устанавливаеться на вершину ветки откуда была перемотка чтобы вернуться назад. Команда `git reset --hard [refC]` тоже сохраняет ссылку в `ORIG_HEAD`  откуда была вызвана команда 

`Удаленные ветки(remote branches)`  представляют собой ссылки на состояние веток в удаленных репозиториях.Ветки смещаються автоматически при подключении по сети. Удаленные ветки работают как напоминание где в удаленных репозиториях находились ветки во время последнего подключения к ним. У различных локальных репо может быть удаленные указатели с различной историей веток.
Удаленная ветка имеет форму `имя удаленного репозитория/ветка`.

При переходе в локальную ветку, созданную из удаленной, автоматически появляется так называемая ветка наблюдения (tracking branch). Это локальная ветка, напрямую связанная с удаленной. Если, находясь на этой ветке, вы наберете команду git push, система Git автоматически поймет, на какой сервер и в какую ветку нужно отправлять данные.При клонировании репозитория автоматически создается ветка master, следящая за веткой origin/master

По мимо слияния веток через `merge` можно также использовать `rebase` для перещения одного коммита на другой с их последущим сливанием. Это работает следующим образом: ищется общий предок двух веток (текущей ветки и ветки, в которую вы выполняете перемещение), вычисляется разница, вносимая каждым коммитом текущей ветки, и сохраняется во временных файлах. После этого текущая ветка сопоставляется тому же коммиту, что и ветка, в которую осуществляется перемещение, и одно за другим происходят все изменения. Плюс данного метода в том что не создаеться коммит слияния веток т.е. получем более аккуратную историю, будет выглядеть как будто работа велась последовательно.Часто это делается, чтобы убедиться в четкости фиксируемых вами состояний на удаленной ветке, например в случае чужого проекта, в который вы хотите внести вклад. В такой ситуации оптимально работать в отдельной ветке, а затем, когда вы почувствуете, что готовы добавить свои исправления к основной версии проекта, переместить данные в ветку origin/master. Это избавит владельца проекта от необходимости заниматься интеграцией — достаточно прибегнуть к перемотке или просто применить добавленные изменения.






 




